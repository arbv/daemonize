# Some hacking to define variables and tools for both Unix and Windows.
# We assume that MinGW/MSYS is Unix (which is true from the viewpoint of GNU Make).
RM := rm -f
CP := cp -f
MKDIR := mkdir -p
RMRF := rm -rf
SUCCESS := true
DIRSEP := /
ifdef PATHEXT
ifneq ($(MAKE_MODE),unix)
NOTUNIX := 1
PWD ?= $(shell echo %cd%)
RM := 2>NUL del /f /q
CP := copy /b /y
MKDIR := 2>NUL mkdir
RMRF := 2>NUL rd /q /s
SUCCESS := exit 0
DIRSEP := \\
else
PWD ?= $(shell pwd)
endif
else
PWD ?= $(shell pwd)
endif

# output directory prefix
OUTDIR_PREFIX := out
# debug suffix
DBG := dbg
# release suffix
REL := rel

# main output
ifdef OBJTYPE
OUTDIR_REL := $(OUTDIR_PREFIX).$(REL).$(OBJTYPE)$(DIRSEP)
OUTDIR_DBG := $(OUTDIR_PREFIX).$(DBG).$(OBJTYPE)$(DIRSEP)
else
OUTDIR_REL := $(OUTDIR_PREFIX).$(REL).$(DIRSEP)
OUTDIR_DBG := $(OUTDIR_PREFIX).$(DBG)$(DIRSEP)
endif

ifdef EXE
OUTSUFFIX := .$(EXE)
else
OUTSUFFIX :=
endif

OUTPUT_REL := $(foreach targ,$(TARGETS),$(OUTDIR_REL)$(notdir $(subst /,$(DIRSEP),$(targ)))$(OUTSUFFIX))
OUTPUT_DBG := $(foreach targ,$(TARGETS),$(OUTDIR_DBG)$(notdir $(subst /,$(DIRSEP),$(targ)))$(OUTSUFFIX))

# object files extension
ifdef OBJTYPE
OBJEXT_REL := $(REL).$(OBJTYPE).$(O)
OBJEXT_DBG := $(DBG).$(OBJTYPE).$(O)
else
OBJEXT_REL := $(REL).$(O)
OBJEXT_DBG := $(DBG).$(O)
endif

# Generate object file names from the source file names
# C and C++ objects
COBJ_REL := $(foreach srcfile,$(SRC)$(CXX_SRC),$(subst /,$(DIRSEP),$(basename $(srcfile)).$(OBJEXT_REL)))
COBJ_DBG := $(foreach srcfile,$(SRC)$(CXX_SRC),$(subst /,$(DIRSEP),$(basename $(srcfile)).$(OBJEXT_DBG)))

# Assembler objects
ASOBJ_REL := $(foreach srcfile,$(AS_SRC),$(subst /,$(DIRSEP),$(basename $(srcfile)).$(OBJEXT_REL)))
ASOBJ_DBG := $(foreach srcfile,$(AS_SRC),$(subst /,$(DIRSEP),$(basename $(srcfile)).$(OBJEXT_DBG)))

# All objects
OBJ_REL := $(COBJ_REL) $(ASOBJ_REL)
OBJ_DBG := $(COBJ_DBG) $(ASOBJ_DBG)

# C/C++ dependencies
DEPS_REL := $(COBJ_REL:.${O}=.d)
DEPS_DBG := $(COBJ_DBG:.${O}=.d)

# current build configuration
ifndef DEBUG
COBJ := $(COBJ_REL)
ASOBJ := $(ASOBJ_REL)
OBJ := $(OBJ_REL)
DEPS := $(DEPS_REL)
OBJEXT := $(OBJEXT_REL)
OUTDIR := $(OUTDIR_REL)
OUTPUT := $(OUTPUT_REL)
else
COBJ := $(COBJ_DBG)
ASOBJ := $(ASOBJ_DBG)
OBJ := $(OBJ_DBG)
DEPS := $(DEPS_DBG)
OBJEXT := $(OBJEXT_DBG)
OUTDIR := $(OUTDIR_DBG)
OUTPUT := $(OUTPUT_DBG)
endif

# files generated by lex and yacc
LEX_OUT := $(subst /,$(DIRSEP),$(LFILES:.l=.lex.c))
YACC_OUT := $(subst /,$(DIRSEP),$(YFILES:.y=.tab.c) $(YFILES:.y=.tab.h))

.PHONY : all debug clean cleanall out mkselfdeploy install uninstall

all:: out

# rule "all" depends on the following rule
out : $(OUTPUT)

# We need to enforce success status to make it work on Windows's cmd.exe
clean ::
	@$(RM) $(OBJ_REL) $(OBJ_DBG) || $(SUCCESS)
	@$(RM) $(DEPS_REL) $(DEPS_DBG) || $(SUCCESS)
	@$(RM)  $(YACC_OUT) $(LEX_OUT) || $(SUCCESS)
	@$(RM) $(OUTPUT_REL)  || $(SUCCESS)
	@$(RM) $(OUTPUT_DBG) || $(SUCCESS)
	@$(RMRF) $(OUTDIR_REL) || $(SUCCESS)
	@$(RMRF) $(OUTDIR_DBG) || $(SUCCESS)

cleanall ::
	@$(RM) $(YACC_OUT) $(LEX_OUT) || $(SUCCESS)
	@$(RM) $(subst /,$(DIRSEP),$(foreach srcfile,$(SRC)$(CXX_SRC)$(AS_SRC),$(wildcard $(basename $(srcfile)).$(DBG).*) $(wildcard $(basename $(srcfile)).$(REL).*))) || $(SUCCESS)
	@$(RMRF) $(subst /,$(DIRSEP),$(wildcard $(OUTDIR_PREFIX).$(DBG).* $(OUTDIR_PREFIX).$(REL).*)) $(OUTDIR_PREFIX).$(DBG) $(OUTDIR_PREFIX).$(REL) || $(SUCCESS)

# Debug target
debug : $(YACC_OUT) $(LEX_OUT)
	@echo "DEBUG BUILD"
	@$(MAKE) DEBUG=1 -s -f $(MAKEFILE_PATH) all

# deploy makefiles into current directory
mkselfdeploy :
	$(CP) $(MKFILES) $(PWD)

%.$(OBJEXT_REL) %.$(OBJEXT_DBG) : %.S
	@echo "AS" $<
	@$(AS) $(ASFLAGS) -o $@ $(subst /,$(DIRSEP),$<)

%.$(OBJEXT_REL) %.$(OBJEXT_DBG) : %.c
	@echo "CC" $<
	@$(CC) $(CFLAGS) $(DEFINES) -c $(subst /,$(DIRSEP),$<) -o $@

%.$(OBJEXT_REL) %.$(OBJEXT_DBG)  : %.cpp
	@echo "CXX" $<
	@$(CXX) $(CXXFLAGS) $(DEFINES) -c $(subst /,$(DIRSEP),$<) -o $@

%.tab.c : %.y
	@echo "BISON" $<
	@$(YACC) $(YFLAGS) $(subst /,$(DIRSEP),$<)

%.lex.c : %.l
	@echo "FLEX" $<
	@$(LEX) $(LFLAGS) -o $@ $(subst /,$(DIRSEP),$<)

# if there is more than one executable to build
ifneq ($(words $(TARGETS)),1)
EXE_OBJ :=  $(foreach targ,$(TARGETS),$(subst /,$(DIRSEP),$(targ)).$(OBJEXT))
COMMON_OBJ := $(filter-out  $(EXE_OBJ),$(OBJ))
define make-single-target-rule
$1 : $2 $(COMMON_OBJ)
	@echo "MKDIR" $(OUTDIR)
	@$(MKDIR) $(OUTDIR) || $(SUCCESS)
	@echo "LD" $1
	@$(LD) $(LDFLAGS) -o $1 $2 $(COMMON_OBJ) $(LDLIBS)
endef
$(foreach targ, $(TARGETS),$(eval $(call make-single-target-rule,$(OUTDIR)$(notdir $(subst /,$(DIRSEP),$(targ)))$(OUTSUFFIX),$(subst /,$(DIRSEP),$(targ)).$(OBJEXT))))
$(OUTPUT) : $(OBJ)
else
$(OUTPUT) : $(OBJ)
	@echo "MKDIR" $(OUTDIR)
	@$(MKDIR) $(OUTDIR) || $(SUCCESS)
	@echo "LD" $@
	@$(LD) $(LDFLAGS) -o $(OUTPUT) $(OBJ) $(LDLIBS)
endif

ifdef GENDEP
-include $(DEPS)
else
$(COBJ) : $(SRC) $(CXX_SRC) $(HEADERS) $(CXX_HEADERS)
endif

$(ASOBJ) : $(AS_SRC) $(AS_INC)

$(OBJ): $(MKFILES) $(YACC_OUT) $(LEX_OUT)

$(YACC_OUT) : $(YFILES)

$(LEX_OUT) : $(LFILES) $(YACC_OUT)

ifndef NOTUNIX
install :: out
	@echo "INSTALLNG to: $(PREFIX)"
	@$(MKDIR) $(BINPREFIX) 
	@echo "CP $(OUTPUT) $(BINPREFIX)/"
	@$(CP) $(OUTPUT) $(BINPREFIX)/
ifdef STRIP
	@$(STRIP) $(BINPREFIX)/$(TARGET)$(OUTSUFFIX)
endif
	@chmod 755 $(BINPREFIX)/$(TARGET)$(OUTSUFFIX)
# If defined manual files
ifdef MANFILES
	@for i in ${MANFILES} ; \
	do \
		manfile="$$(basename $${i})"; \
		mancat="$${manfile##*.}"; \
		manpath="${MANPREFIX}/man$${mancat}"; \
		\
		echo "CP $${manfile} $${manpath}"; \
		mkdir -p $${manpath}; \
		cp -f $${i} $${manpath}; \
		chmod 644 $${manpath}/$${manfile}; \
	done
endif

UNINSTALL_NAMES = $(foreach n,$(OUTPUT),$(BINPREFIX)/$(notdir $(n)))

uninstall ::
	@echo "UNINSTALLING from: $(PREFIX)"
	@echo "RM $(UNINSTALL_NAMES)"
	@$(RM) $(UNINSTALL_NAMES)
# If defined manual files
ifdef MANFILES
	@for i in ${MANFILES} ; \
	do \
		manfile="$$(basename $${i})"; \
		mancat="$${manfile##*.}"; \
		manpath="${MANPREFIX}/man$${mancat}"; \
		\
		echo "RM $${manpath}/$${manfile}"; \
		rm -f $${manpath}/$${manfile}; \
	done
endif

endif # NOTUNIX

